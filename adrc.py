"""
Contains the Adrc class to adapt or reconstruct words
"""

from ast import literal_eval
from collections import Counter, OrderedDict
from itertools import count, cycle, product #ðŸš²
from math import prod
from operator import itemgetter

from tqdm import tqdm

from loanpy.helpers import (Etym, apply_edit, clusterise,
                            combine_ipalists, editops,
                            edit_distance_with2ops, flatten,
                            get_howmany, list2regex, tokenise)
from loanpy.qfysc import Qfy

def read_scdictlist(scdictlist):
    if scdictlist is None: return [None]*4
    with open(scdictlist, "r", encoding="utf-8") as f:
        return literal_eval(f.read())[:4]

def move_sc(sclistlist, whichsound, out):
    out[whichsound].append(sclistlist[whichsound][1]) # transfer the sound to out
    sclistlist[whichsound] = sclistlist[whichsound][1:]  # move input by 1
    return sclistlist, out

class Adrc(Qfy):
    """
    Adapts or reconstructs words based on etymological and statistical data

    :param substi: name of the dictionary containing the sound substitutions. \
    Generated by loanpy.qfysc.Qfy().dfetymology2dict()
    :type substi: str, default="substi.txt"

    :param photct: name of the file containing the list of allowed phonotactic structures
    :type photct: str, default="phonotactics.txt"

    :param sndcng: name of the file containing sound changes
    :type sndcng: str, default="scdict.txt"

    :param se_or_edict: name of the file containing the sum of examples, or examples
    :type se_or_edict: str, default="sedict.txt"

    """
    def __init__(self, srclg=None, tgtlg=None, scdictlist=None, scdictbase=None,
                 formscsv=None, mode=None, struc_most_frequent=9999999, struc_inv=None):
        """inits Adrc with allowed phonotactics, dictionaries of sound substitution and sound changes """

        super().__init__(formscsv=formscsv, srclg=srclg, tgtlg=tgtlg, mode=mode,
                         struc_most_frequent=struc_most_frequent, struc_inv=struc_inv,
                         scdictbase=scdictbase)

        self.scdict, self.sedict, self.edict, self.scdict_struc = read_scdictlist(scdictlist)

        self.workflow = OrderedDict()

    def get_diff(self, sclistlist, ipa):
        difflist = []
        firstsclist = []
        for idx, sclist in enumerate(sclistlist):

            firstsc = self.sedict.get(ipa[idx] + self.connector + sclist[0], 0)
            firstsclist.append(firstsc)

            # exception 1:
            if len(sclist) == 2:  # if list has reached the end
                difflist.append(float("inf"))  # indicate that it cant be moved = stop button
                continue

            # exception 2: no data available anymore
            if firstsc == 0: #no data available
                difflist.append(9999999) # pause button, may be unfreezed later
                continue

            nextsc = self.sedict.get(ipa[idx] + self.connector + sclist[1], 0)
            difflist.append(firstsc - nextsc)

        return difflist

    def read_sc(self, ipa, howmany=1):
        #if isinstance(ipa, str):  # if str not tokenised yet
        #    ipa = tokenise(ipa)  # tokenise it

        sclistlist = [self.scdict[i] for i in ipa]  # grab the soundchanges
        if howmany >= prod([len(scl) for scl in sclistlist]): return sclistlist #<if howmany is bigger than the product

        sclistlist = [sclist+["$"] for sclist in sclistlist]
        out = [[i[0]] for i in sclistlist] #grab first sound changes for output
        while howmany > prod([len(scl) for scl in out]):  #get_diff needs the next sound
            difflist = self.get_diff(sclistlist, ipa)  # which one should we move?
            #print("dl: ", difflist, "\nsclist: ", sclistlist, "\nout: ", out)
            minimum = min(difflist)  # the one that makes the least difference!
            indices = [i for i, v in enumerate(difflist) if v == minimum]  # woops, someimtes multiple values make the least difference
            if len(indices) == 1: #if only 1 element makes the least difference
                sclistlist, out = move_sc(sclistlist, indices[0], out) # grab it
                continue # thats it

            difflist2 = difflist #but if multiple elements are the minimum...
            idxpool = cycle(indices) #...then cycle through them... ðŸš²
            while difflist2 == difflist and howmany > prod([len(scl) for scl in out]):
            #...until something changes about the differences they make
            # latest if a sound reaches the end of the list it turns to infinite
                sclistlist, out = move_sc(sclistlist, next(idxpool), out)
                difflist2 = self.get_diff(sclistlist, ipa)
                #print("difflist2: ", difflist2, "\nsclist: ", sclistlist, "\nout: ", out)

        return out

    def reconstruct(self, ipastring, howmany=1, clusterised=True,
                    struc=False, vowelharmony=False, sort_by_nse=False):
        """
        Takes a modern-day L1 word as input and creates a list of possible \
        reconstructions into proto-L1.

        :param ipastring: A modern-day L1-word
        :type ipastring: str

        :param fp: The number of reconstructions to generate. Sound changes are \
         gradually added in decreasing order of likelihood.
        :type fp: int, default=1

        :param struc: Indicate whether words should be filtered out that violate \
         phonotactic constraints.
        :type struc: bool, default=False

        :param vowelharmony: Indicate whether words should be filtered out that violate \
         vowelharmonic constraints.
        :type vowelharmony: bool, default=False

        :param clusterised: Indicate whether words should be filtered out \
         if they containt consonant or vowel clusters that are undocumented in the etymological \
         dictionary.
        :type clusterised: bool, default=True

        :param sort_by_nse: Indicate whether reconstructions should be sorted by \
         their likelihood.
        :type sort_by_nse: bool, default=False

        :return: a regular expression
        :rtype: str

        :Example:

        >>> from loanpy import adrc
        >>> rc = adrc.Adrc()
        >>> rc.reconstruct('mÉ’ÉŸÉ’r', fp=100)
        '^(m)(É‘|V|u|o|È£|e|Ã¦)(nÊ²tÍ¡ÊƒÊ²|j|Ã°Ê²|lj|l|n|tÍ¡ÊƒÊ²)(É‘|V|u)(r)(V)$'

        >>> from loanpy import adrc
        >>> rc = adrc.Adrc()
        >>> rc.reconstruct('mÉ’ÉŸÉ’r', fp=5, struc=True, vowelharmony=True, clusterised=True)
        '^mÉ‘jÉ‘rV$|^mÉ‘Ã°Ê²É‘rV$|^mÉ‘lÉ‘rV$'

        """
        ipalist = clusterise(ipastring) if clusterised else tokenise(ipastring)

        ipalist[0], ipalist[-1] = f"#{ipalist[0]}", f"{ipalist[-1]}#"
        ipalist = ["#-"] + ipalist + ["-#"]

        if not all(phon in self.scdict for phon in ipalist):
            return f"{', '.join([i for i in ipalist if i not in self.scdict])} not old"

        out = self.read_sc(ipalist, howmany)

        if all(i is False for i in [struc, vowelharmony, sort_by_nse]):
            return f"^{''.join([list2regex(i) for i in out])}$"

        out = ["".join(i).replace("-", "") for i in product(*out)]

        if struc is True:
            out = [i for i in out if self.word2struc(i) in self.struc_inv]
            if out == []: return "wrong phonotactics"

        if vowelharmony is True:
            out = [i for i in out if self.harmony(i)]
            if out == []: return "wrong vowel harmony"

        if sort_by_nse is True:
            nse = map(lambda x: self.get_nse(ipastring, x), out)
            out = [i[1] for i in sorted(zip(nse, out), reverse=True)]

        if howmany != float("inf"): out = out[:howmany]
        return f"^{'$|^'.join(out)}$"

    def adapt_struc(self, ipa_in, max_struc=2, max_paths=1, show_workflow=False):
        """adapt phonotactic structure of word"""

        if isinstance(ipa_in, str): ipa_in = tokenise(ipa_in)
        if max_struc == 1: return [ipa_in]
        donorstruc = self.word2struc(ipa_in)
        if show_workflow: self.workflow["donor_struc"] = [donorstruc]

        try: pred_strucs = self.scdict_struc[donorstruc][:max_struc]
        except KeyError: pred_strucs = self.rank_closest_struc(donorstruc, max_struc).split(", ")
        if show_workflow: self.workflow["pred_strucs"] = [pred_strucs]
        return flatten([[apply_edit(ipa_in, eo) for eo
        in editops(donorstruc, pred, max_paths)] for pred in pred_strucs])

    def adapt(self, ipa_in, howmany=1, max_struc=1, max_paths=1, vowelharmony=False,
              clusterised=False, sort_by_nse=False, struc_filter=False, show_workflow=False):
        """
        Takes an L2 word and adapts it to the constraints of L1

        :param ipa_in: An L2 word consisting of characters of the \
         International Phonetic Alphabet (IPA).
        :type ipa_in: str

        :param fp: Indicate how many adaptions to return.
        :type fp: int, default=1

        :param struc: Indicate whether words should be adapted to \
         phonotactic constraints.
        :type struc: bool, default=True

        :param vowelharmony: Indicate whether words should be adapted \
         to vowelharmonic constraints
        :type vowelharmony: bool, default=True

        :param clusterised: Indicate whether only those words should \
         be accepted that consist only of consonant or vowel clusters that are documented in \
         the etymological dictionary of L1.
        :type clusterised: bool, default=True

        :param sort_by_nse: Indicate whether adaptations should be sorted by \
         their likelihood.
        :type sort_by_nse: bool, default=False

        :return: The most likely adaptations into proto-L1
        :rtype: str

        :Example:

        >>> from loanpy import adrc
        >>> ad = adrc.Adrc()
        >>> ad.adapt("wulÉ¸Éªla", fp=1, struc=False, vowelharmony=False, clusterised=False)
        'ulwilÉ‘'

        >>> from loanpy import adrc
        >>> ad = adrc.Adrc()
        >>> ad.adapt("wulÉ¸Éªla", fp=2, struc=True, vowelharmony=False, clusterised=False)
        'wulilÉ‘'

        >>> from loanpy import adrc
        >>> ad = adrc.Adrc()
        >>> ad.adapt("wulÉ¸Éªla", fp=5, struc=False, vowelharmony=True, clusterised=False)
        'ulwÉ‘lÉ‘, ulwVlÉ‘, VlwÉ‘lÉ‘, VlwVlÉ‘, wulwÉ‘lÉ‘'

        >>> from loanpy import adrc
        >>> ad = adrc.Adrc()
        >>> ad.adapt("wulÉ¸Éªla", fp=20, struc=True, vowelharmony=True, clusterised=True, sort_by_nse=True)
        'wulÉ‘lÉ‘, wulÉ‘lÃ¦, wulVlÉ‘, wulVlÃ¦, wVlÉ‘lÉ‘, wVlÉ‘lÃ¦, wVlVlÉ‘, wVlVlÃ¦, lÉ‘lÉ‘, lÉ‘lÃ¦, lVlÉ‘, lVlÃ¦'

        """
        max_phon, max_struc, max_paths = get_howmany(howmany, max_struc, max_paths)
        self.workflow, out = OrderedDict(), tokenise(ipa_in)
        if show_workflow: self.workflow["tokenised"] = [out]

        out = self.adapt_struc(out, max_struc, max_paths, show_workflow) #list of ipalists
        if show_workflow: self.workflow["adapted_struc"] = [out]

        if vowelharmony:
            out = flatten(map(self.adapt_harmony, out))
            if show_workflow: self.workflow["adapted_vowelharmony"] = [out]

        out = [self.read_sc(ipalist, max_phon) for ipalist in out]

        if show_workflow: self.workflow["before_combinatorics"] = [out]

        out = combine_ipalists(out)

        if struc_filter: #b/c 1 phoneme is not always substituted by exactly 1 phoneme, e.g. "-"
            out = [i for i in out if self.word2struc(i) in self.struc_inv]
            if out == []: return "wrong phonotactics"

        if clusterised:
            out = [wrd for wrd in out if all(cl in self.clusters for cl in clusterise(wrd))]
            if out == []: return "wrong clusters"

        if sort_by_nse:
            out = [(self.get_nse(ipa_in, i), i) for i in out]
            out.sort(key=itemgetter(0), reverse=True)
            out = [i[1] for i in out]

        return ", ".join(out[:howmany])

    def get_nse(self, left, right, se=True, show_workflow=False):
        if not left or not right: return 0
        nsedict = self.sedict if se is True else self.edict
        dfsc = self.align(left, right)
        sc = dfsc["vals"] + self.connector + dfsc["keys"] if self.mode == "adapt" else dfsc["keys"] + self.connector + dfsc["vals"]
        outlist = [nsedict.get(i, 0) for i in sc]
        if se is True:
            outsum = sum(outlist)
            normalised_outsum = outsum / len(dfsc)
            if show_workflow is True:
                return normalised_outsum, outsum, outlist
            return normalised_outsum
        return outlist
